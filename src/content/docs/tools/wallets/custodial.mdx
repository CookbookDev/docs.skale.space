---
title: Custodial Wallets
description: Intro to Custodial Wallets
---
import { Tabs, TabItem } from '@astrojs/starlight/components';
import ToolLayout from "../../../../components/Tool/ToolLayout.astro";


<Tabs>
<TabItem label="Stardust">
<ToolLayout
    introParagraph="Stardust solution allows developers to quickly create custodial wallets, manage their NFTs, and monetize their collections on a robust marketplace."
    toolName="Stardust"
    toolLink="https://docs.stardust.gg/docs"
    toolDocsLink="https://docs.stardust.gg/docs"
>

With this solution it's possible to create a frictionless user onboarding experience, by removing the need for them to manage their own private keys.

## Implementation Example 

The following example provides a number of examples on how to use Stardust WaaS. The default chain used is SKALE Chaos Testnet. For the full code repo go [here](https://github.com/Dirt-Road-Development/stardust-examples)

````javascript
const { StardustCustodialSDK, StardustApp, StardustWallet } = require("@stardust-gg/stardust-custodial-sdk");
const { STARDUST_API_KEY, RPC_URL } = require("../../config");
const createStardustWallet = require("./createWallet");
const { providers } = require("ethers");
const getStardustWallet = require("./getWallet");

function stardust() {
	const provider = new providers.JsonRpcProvider(RPC_URL);
	const sdk = new StardustCustodialSDK(STARDUST_API_KEY);

	async function getWallet(walletId) {
		return await getStardustWallet(sdk, walletId);
	}

	return {
		createWallet: async() => createStardustWallet(sdk),
		getWallet,
		getSigner: async(walletId) => {
			const wallet = await getWallet(walletId);
			return wallet.signers.ethers.connect(provider);
		}
	}
}
module.exports = stardust();
````

</ToolLayout>
</TabItem>
<TabItem label="Insible Signer">
<ToolLayout
    introParagraph="Thanks to the zero gas fees nature of the SKALE chains projects can perform transactions on behalf of the users without compromising the company sustainability by covering huge gas fees costs. In order to achieve the described above, the application can generate on the background a wallet for each user, distribute the free gas token to it and store it on the backend."
    toolName="Invisible Signers"
    toolLink=""
    toolDocsLink=""
>

Every time a user performs a transaction, the background wallet signs the transaction without the user having idea he just made a on-chain transaction.

## Implementation Example

This [codebase](https://github.com/skalenetwork/recipes/tree/recipe-api-background-signer/typescript) uses the Typescript language along with the Viem library to showcase a proof of concept on how to utilize background signers within an API or Server based environment. 

This example also uses a sticky session per userId meaning that the randomly generated accounts are mapped 1:1 with a userId. This will persist only for the duration of the service liftetime. On application crash or restart new wallets will be created. To resolve these types of issues you can encrypt the private keys and store them in something like Redis to make a more sophisticated service that would also allow for multiple AZ usage.

1. Custodian

````typescript
import { initializeCustodian } from "./utils";
import { createClient } from "./utils";
import { CUSTODIAN_PRIVATE_KEY, WSS_URL } from "./config";
import { parseEther } from "viem";

const DEFAULT_FILL_UP_VALUE: bigint = parseEther("0.00000002");

class Custodian {
    #nonce = 0;
    #custodian;
    #client;

    constructor() {
        this.#custodian = initializeCustodian(CUSTODIAN_PRIVATE_KEY as `0x${string}`);
        this.#client = createClient(WSS_URL);
    }

    public get custodian() {
        return this.#custodian;
    }

    public get client() {
        return this.#client;
    }

    public async isValidCustodian() {
        const balance = await this.#client.getBalance({
            address: this.#custodian.account.address
        });

        if (balance < parseEther("0.00005")) {
            throw new Error("Custodian Balance must be > 0.00005");
        }

        this.#nonce = await this.#client.getTransactionCount({
            address: this.#custodian.account.address
        });
    }

    public async distribute(to: `0x${string}`) {
        const hash = await this.#custodian.sendTransaction({
            to,
            value: DEFAULT_FILL_UP_VALUE,
            nonce: this.#nonce++
        });
        const tx = await this.#client.waitForTransactionReceipt({
            hash
        });
    }
}
export default new Custodian();

````

2. Background Signers 

````typescript
import { WalletClient, getAddress, parseAbi } from "viem";
import Custodian from "./custodian";
import { createSigner } from "./utils";
import { skaleChaosTestnet } from "viem/chains";
import { Contract } from "./contract";

class BackgroundSigners {
    #custodian: typeof Custodian;
    #signers: {[key: string]: WalletClient} = {};

    constructor() {
        this.#custodian = Custodian;
    }

    
    public async getUser(userId: string) {
        if (this.#signers[userId] === undefined) {
            const signer = createSigner();
            this.#signers[userId] = signer;
            await this.#custodian.distribute(signer.account.address);
            
        }
        
        return this.#signers[userId].account?.address as `0x${string}`;
    }

    public async remove(userId: string) {
        const account = this.#signers[userId].account;
        if (!account) return;
        this.#signers[userId].sendTransaction({
            to: this.#custodian.custodian.account.address,
            value: BigInt(1),
            type: "legacy",
            account,
            chain: skaleChaosTestnet
        });
    }

    public async backgroundSignerAction(userId: string, args: any[], functionName: "mint" | "burn") {
        const account = this.#signers[userId].account;
        if (!account) throw new Error("Account Not Found");

        await this.#signers[userId].writeContract({
            abi: Contract.abi,
            address: getAddress(Contract.address),
            functionName,
            args,
            account,
            chain: skaleChaosTestnet
        })
    }
}

export default new BackgroundSigners();
````

3. API

````typescript
import { Router } from "express";
import BackgroundSigners from "./background_signers";
import { parseEther } from "viem";

const router = Router();

router.post("/mint", async (req, res) => {
    const userId: string = req.body.userId;
    const address = await BackgroundSigners.getUser(userId);
    
    try {
        await BackgroundSigners.backgroundSignerAction(userId, [address, parseEther("1")], "mint");
        return res.status(200).send("Minted Successfully");
    } catch (err) {
        return res.status(500).send("Error Minting");
    }
});

router.post("/burn", async (req, res) => {
    const userId: string = req.body.userId;
    const address = await BackgroundSigners.getUser(userId);
    
    try {
        await BackgroundSigners.backgroundSignerAction(userId, [parseEther("1")], "burn");
        return res.status(200).send("Burned Successfully");
    } catch (err) {
        return res.status(500).send("Error Burning");
    }
});

export default router;
````


</ToolLayout>
</TabItem>
</Tabs>